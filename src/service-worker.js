import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
//import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute, Route } from "workbox-routing";
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies";
// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
//precacheAndRoute(self.__WB_MANIFEST);
const ignored = self.__WB_MANIFEST;

const versionStyles = 1.03;
const versionScripts = 1.03;
const versionImages = 1.04;
const versionFonts = 1.04;
const versionHtmls = 1.03;


const cachesCurrent = {
	styles: `styles-${versionStyles}`,
	scripts: `scripts-${versionScripts}`,
	images: `images-${versionImages}`,
	fonts: `fonts-${versionFonts}`,
	htmls: `htmls-${versionHtmls}`
};


clientsClaim();



// Handle styles:
const stylesRoute = new Route(({ request }) => {
	//request.destination === "style" && console.log("req style: ", request.url);
	return request.destination === "style";
}, new CacheFirst({
	cacheName: cachesCurrent.styles,
	plugins: [
		new ExpirationPlugin({
		  maxAgeSeconds: 60 * 60 * 24 * 30,
		  maxEntries: 20,
		})
	  ]
}));

const scriptsRoute = new Route(({ request }) => {
	//request.destination === "script" && console.log("req script: ", request.url);
	return request.destination === "script";
}, new CacheFirst({
	cacheName: cachesCurrent.scripts,
	plugins: [
		new ExpirationPlugin({
		  maxAgeSeconds: 60 * 60 * 24 * 30,
		  maxEntries: 20,
		})
	  ]
}));

const imagesRoute = new Route(({ request }) => {
	//request.destination === "image" && console.log("req image: ", request.url);
	return request.destination === "image";
}, new CacheFirst({
	cacheName: cachesCurrent.images,
	plugins: [
		new ExpirationPlugin({
		  maxAgeSeconds: 60 * 60 * 24 * 30,
		  maxEntries: 50,
		})
	  ]
}));


const fontsRoute = new Route(({ request }) => {
	return request.destination === "font";
}, new StaleWhileRevalidate({
	cacheName: cachesCurrent.fonts,
	plugins: [
		new ExpirationPlugin({
		  maxAgeSeconds: 60 * 60 * 24 * 30,
		  maxEntries: 10,
		})
	  ]
}));

/*
const htmlsRoute = new Route(({ request }) => {
	return request.destination === "html";
}, new StaleWhileRevalidate({
	cacheName: cachesCurrent.htmls
}));
*/

registerRoute(stylesRoute);
registerRoute(scriptsRoute);
registerRoute(imagesRoute);
registerRoute(fontsRoute);
//registerRoute(htmlsRoute);



// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

//auto set new sw
self.addEventListener("install", event => {
	console.log("ServiceWorker will be updated in a moment...");
	self.skipWaiting();
}); 


self.addEventListener("activate", async event => {
	/*if (self.registration.navigationPreload) {
		await self.registration.navigationPreload.enable();
	}*/
	const siteCahceKeys = await caches.keys();
	const cacheKeys = Object.values(cachesCurrent);

	console.log("siteCahceKeys: ", siteCahceKeys);
	console.log("cacheKeys: ", cacheKeys);

	await siteCahceKeys
		.filter(cache => {
			console.log("Current: ", cache, !cacheKeys.includes(cache));
			return !cacheKeys.includes(cache);
		})
		.forEach(async cache => await caches.delete(cache));
}); 

//const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
//const imageType = new RegExp("/(jpe?g|png|gif|bmp)$/");